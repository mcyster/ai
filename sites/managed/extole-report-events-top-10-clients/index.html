<html ng-app="jsonFormatterApp">
<head>
    <meta charset="UTF-8">
    <title>Extole Top Client Event Traffic</title>
    <meta name="tags" content="extole,report,kpis,top,clients,events">
    <script src="https://cdn.jsdelivr.net/npm/vue@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="/sites/managed/chat/chat.js" data-scenario="WebDeveloper" data-href-website-id="/([^/]+)/[^/]+$"></script>
    <script src="data.js"></script>
    <style>
        #graphTitle {
            text-align: center;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .chart-container {
            width: 80%;
            margin: auto;
            max-width: 2400px;
        }
        #jsonDisplay {
            padding: 20px;
            margin: 20px auto;
            width: 80%;
            max-width: 2400px;
            border: 1px solid #ddd;
            display: none;
        }
        .json-toggler {
            cursor: pointer;
            color: #007BFF;
            margin: 20px auto;
            width: 80%;
            max-width: 2400px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="chart-container">
        <h2 id="graphTitle">Top 10 Clients Event Traffic</h2>
        <canvas id="chart"></canvas>
    </div>
    <div class="json-toggler" onclick="toggleJsonDisplay()">Show JSON Data</div>
    <div id="jsonDisplay"></div>
</body>
<script>
document.addEventListener("DOMContentLoaded", async function() {
    async function showData() {
        try {
            var data = await getReport();
            console.log('Data fetched successfully:', data);
            const dataDisplay = document.getElementById('jsonDisplay');
            if (data) {
                dataDisplay.innerHTML = '<pre>' + JSON.stringify(data, null, 2) + '</pre>';
            } else {
                dataDisplay.innerHTML = '<pre>No data available</pre>';
            }

            // filtering for the trailing 12 months
            const now = new Date();
            const trailingYear = new Date();
            trailingYear.setMonth(now.getMonth() - 12);
            const filteredData = data.filter(item => new Date(item.period_end) > trailingYear);

            // Summing events by client
            const eventCountByClient = filteredData.reduce((acc, item) => {
                const clientID = item.client_id;
                acc[clientID] = (acc[clientID] || 0) + item.events_count;
                return acc;
            }, {});

            // Sorting to get top 10 clients
            const topClients = Object.entries(eventCountByClient)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 10)
                .map(([clientID]) => clientID);

            // Filtering data for these top 10 clients
            const topClientsData = filteredData.filter(item => topClients.includes(item.client_id));

            // Create a map of client IDs to names
            const clientNames = {};
            topClientsData.forEach(item => {
                if (!clientNames[item.client_id]) {
                    clientNames[item.client_id] = item.client_name;
                }
            });

            // Aggregating data for each client over time
            const aggregatedData = topClientsData.reduce((acc, item) => {
                const date = item.period_end;
                const clientID = item.client_id;
                if (!acc[clientID]) acc[clientID] = {};
                acc[clientID][date] = (acc[clientID][date] || 0) + item.events_count;
                return acc;
            }, {});

            const colors = generateColors(Object.keys(aggregatedData).length);

            const datasets = Object.entries(aggregatedData).map(([clientID, eventsByDate], index) => {
                const borderColor = colors[index];
                return {
                    label: clientNames[clientID] || `Client ${clientID}`,
                    data: Object.entries(eventsByDate).map(([date, count]) => ({ x: date, y: count })),
                    borderColor: borderColor,
                    backgroundColor: borderColor,
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                };
            });

            // Create the line chart
            const ctx = document.getElementById('chart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month'
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                font: {
                                    weight: 'bold'
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Event Count',
                                font: {
                                    weight: 'bold'
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });

        } catch (error) {
            console.error('Error fetching data:', error);
        }
    }

    showData();

    function generateColors(numColors) {
        const colors = [];
        const hueStep = 360 / numColors;
        for (let i = 0; i < numColors; i++) {
            const hue = i * hueStep;
            const color = `hsl(${hue}, 50%, 45%)`;
            colors.push(color);
        }
        return colors;
    }
});

function toggleJsonDisplay() {
    const jsonDisplay = document.getElementById('jsonDisplay');
    const toggler = document.querySelector('.json-toggler');
    if (jsonDisplay.style.display === 'none' || jsonDisplay.style.display === '') {
        jsonDisplay.style.display = 'block';
        toggler.innerText = 'Hide JSON Data';
    } else {
        jsonDisplay.style.display = 'none';
        toggler.innerText = 'Show JSON Data';
    }
}

async function getReport() {
    var extoleClientId = "1890234003";
    var reportRunnerId = "s869x14kpawsodmdk0f8";
    var data = await getTypedData(extoleClientId, reportRunnerId);

    if (reportRunnerId != "s869x14kpawsodmdk0f8") {
        throw new Error(`Update the typeData in getReport to match the reportRunnerId: ${reportRunnerId} for client ${extoleCientId}`);
    }

    var typedData = data.map(item => ({
        period_end: item.period_end || null,
        client_id: item.client_id || null,
        client_name: item.client_name || null,
        client_type: item.client_type || null,
        vertical: item.vertical || null,
        client_status: item.client_status || null,
        integration_name: item.integration_name || null,
        integration_type: item.integration_type || null,
        destination: item.destination || null,
        events: item.events || null,
        events_count: item.events_count || 0,
    }));

    return typedData;
}
</script>
</html>
